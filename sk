#!/usr/bin/env python3

import threading
import os,sys
import time
import argparse
import readline     # interactive mode history at input()
import datetime
import logging
import queue

import serial
from serial.tools.list_ports import comports


# TODO log to file

formatter_info = logging.Formatter('%(message)s')
formatter_debug = logging.Formatter('%(levelname)5s %(module)3s.%(funcName)-10s %(lineno)3s %(message)s')

logger = logging.getLogger('serialkiller')
logger.setLevel(logging.DEBUG)

streamhandler = logging.StreamHandler(sys.stdout)
streamhandler.setLevel(logging.DEBUG)
logger.addHandler(streamhandler)

class Helper():
    def colorize(self, string, color):
        colors = {}
        colors['black']    = '\033[0;30m'
        colors['bblack']   = '\033[1;30m'
        colors['red']      = '\033[0;31m'
        colors['bred']     = '\033[1;31m'
        colors['green']    = '\033[0;32m'
        colors['bgreen']   = '\033[1;32m'
        colors['yellow']   = '\033[0;33m'
        colors['byellow']  = '\033[1;33m'
        colors['blue']     = '\033[0;34m'
        colors['bblue']    = '\033[1;34m'
        colors['magenta']  = '\033[0;35m'
        colors['bmagenta'] = '\033[1;35m'
        colors['cyan']     = '\033[0;36m'
        colors['bcyan']    = '\033[1;36m'
        colors['white']    = '\033[0;37m'
        colors['bwhite']   = '\033[1;37m'
        colors['reset']    = '\033[0m'
        colors['default']    = '\033[0m'

        return colors[color] + string + colors["reset"]


class LockFile():
    def __init__(self, path):
        self.lockfile = path

    def is_locked(self):
        return os.path.isfile(self.lockfile)

    def lock(self):
        with open(self.lockfile, 'w'):
            pass
        logger.info(f"Created lockfile: {self.lockfile}")

    def unlock(self):
        try:
            os.remove(self.lockfile)
            logger.info(f"Removed lockfile: {self.lockfile}")
        except FileNotFoundError:
            logger.error('Serialkiller is not locked')


class SerialConnThread(threading.Thread, LockFile):
    def __init__(self, lockfile):
        threading.Thread.__init__(self)
        LockFile.__init__(self, lockfile)
        self.stopped = False

        # connection info, is filled in by connect()
        self.ports = None
        self.baudrate = None
        self.timeout = None
        self.url = None

        # holds serial connection object
        self.ser = None

    def connect_TCP(self, url, timeout=0):
        # Create connection over TCP
        try:
            self.ser =  serial.serial_for_url(url, timeout=1)
            logger.info(f"Connected to {url} | Exit using CTRL+C")
            self.url = url
            return self.ser
        except serial.serialutil.SerialException as e:
            logger.error(e)

    def connect_serial(self, port, baudrate, timeout=0):
        # Create connection over Serial port
        try:
            self.ser = serial.Serial(port, baudrate, timeout=timeout, exclusive=True)
            logger.info(f"Connected to {port} @ {baudrate} | Exit using CTRL+C")

            # save serial connection info so we can reconnect quicker
            self.port = port
            self.baudrate = baudrate
            self.timeout = timeout
            return self.ser
        except serial.serialutil.SerialException as e:
            logger.error(e)

    def try_connect_ports(self, ports, baudrate, timeout=0):
        # try all ports in list, NOTE discovery is somehow super slow from thread
        for port in ports:
            logger.info(f"Trying to connect to {port}")
            if self.connect_serial(port, baudrate, timeout):
                return True
        else:
            logger.error("No serial ports found")

    def stop(self):
        logger.debug("Stopping connection manager thread")
        self.stopped = True

    def get_char(self):
        # TODO handle pause on this level
        if self.ser == None:
            return
        if not self.ser.is_open:
            return
        if self.is_locked():
            return

        try:
            return self.ser.read().decode()
        except UnicodeDecodeError as e:
            logger.error(e)
            logger.error(f"Wrong baudrate? {self.baudrate}")

    def send(self, data):
        # TODO handle pause on this level
        if self.ser == None:
            return
        if self.is_locked():
            logger.error("Serial is locked")
            return

        self.ser.write(data.encode())

    def close(self):
        if self.ser != None:
            logger.info("Closing connection")
            self.ser.close()

    def run(self):
        logger.debug("Starting connection manager thread")
        msg_shown = False

        while not self.stopped:
            # if serial is locked
            if self.is_locked():
                if not msg_shown:
                    logger.info("Serial is locked")
                    msg_shown = True
                    self.ser.close()

            # if serial was locked
            elif msg_shown:
                msg_shown = False
                logger.info("Serial is unlocked")
                if not self.ser.is_open:
                    if self.url:
                        self.connect_TCP(self.url, self.timeout)
                    else:
                        self.connect_serial(self.port, self.baudrate, self.timeout)


        self.close()


class ReaderThread(threading.Thread, LockFile, Helper):
    def __init__(self, lockfile, conn_manager, log_file_path):
        threading.Thread.__init__(self)
        LockFile.__init__(self, lockfile)
        self.stopped = False
        self.conn_manager = conn_manager
        self.paused = False
        self.log_file_path = log_file_path

        # queue holds received messages that we can process by other threads
        self.q = queue.Queue()

    def stop(self):
        logger.debug("Stopping reader thread")
        self.stopped = True

    def pause(self, state):
        self.paused = state

    def sanitize(self, data):
        return data.strip()

    def non_blocking_read(self):
        buf = ''
        while not self.stopped:

            if self.paused:
                continue

            c = self.conn_manager.get_char()

            if not c:
                continue
            elif c == '\n':
                return buf
            else:
                buf += c

    def write_to_log_file(self, data):
        with open(self.log_file_path, 'a') as f:
            f.write(data + '\n')

    def run(self):
        logger.debug("Starting reader thread")
        while not self.stopped:

            try:
                data = self.non_blocking_read()
            except serial.serialutil.SerialException as e:
                continue

            if data == None:
                continue

            data = self.sanitize(data)

            if data:
                # append to queue so we can process messages from other threads
                self.q.put(data)

                print(self.colorize('<', 'bgreen'), data)

                # log to file
                if self.log_file_path:
                    self.write_to_log_file(data)


class InputBaseClass(Helper):
    def __init__(self, conn_manager_thread, reader_thread, history_path):
        self.reader_thread = reader_thread
        self.conn_manager_thread = conn_manager_thread
        self.history_path = history_path

    def send_data(self, data):
        self.reader_thread.pause(True)
        self.conn_manager_thread.send(data + '\n')
        self.reader_thread.pause(False)
        print(self.colorize('>', 'bmagenta'), data)


class InputUser(InputBaseClass):
    def __init__(self, conn_manager_thread, reader_thread, history_path):
        super().__init__(conn_manager_thread, reader_thread, history_path)

    def get_input(self):
        logger.debug("Starting reading from user input")
        while True:
            data =  input()
            readline.write_history_file(self.history_path)

            if data:
                self.send_data(data)


class InputSTDIN(InputBaseClass):
    def __init__(self, conn_manager_thread, reader_thread, history_path, confirm_str, confirm_timeout, confirm_wait):
        super().__init__(conn_manager_thread, reader_thread, history_path)
        self.confirm_str = confirm_str
        self.confirm_timeout = confirm_timeout
        self.confirm_wait = confirm_wait

    def wait_for_str(self, confirm_str, timeout=5):
        msg = ''
        t = datetime.datetime.now()

        # wait till we get the expected response, timeout if not
        while msg != confirm_str:
            if (datetime.datetime.now() - t) > datetime.timedelta(seconds=timeout):
                logger.error("Message timed out")
                return
            if not self.reader_thread.q.empty():
                msg = self.reader_thread.q.get()
        return msg

    def get_input(self):
        if self.confirm_str:
            logger.info(f"Starting reading from STDIN, string={self.confirm_str}, timeout={self.confirm_timeout} sec")
        else:
            logger.info(f"Starting reading from STDIN, wait={self.confirm_wait} sec")

        # fast forward, empty queue
        while not self.reader_thread.q.empty():
            self.reader_thread.q.get()

        for c,l in enumerate(sys.stdin):
            l = l.rstrip('\n')

            if not l:
                continue

            print(self.colorize(f"< [{c}]", "bblue"), l)
            self.send_data(l)

            # wait for response, either by response string or wait time
            if self.confirm_str:
                self.wait_for_str(self.confirm_str, self.confirm_timeout)
            else:
                time.sleep(self.confirm_wait)

        logger.debug("STDIN buffer empty")


class SerialKiller(LockFile, Helper):
    def __init__(self):
        self.lockfile = '/tmp/serialkiller.lock'
        LockFile.__init__(self, self.lockfile)

        # readline lib will use this file to read/write history
        self.history_path = '/tmp/sk_history.txt'
        try:
            readline.read_history_file(self.history_path)
        except FileNotFoundError:
            pass

    def stop_threads(self):
        self.reader_thread.stop()
        self.conn_manager_thread.stop()

    def start_threads(self):
        # this thread is passed to every thread that needs serial access
        self.conn_manager_thread = SerialConnThread(self.lockfile)
        self.conn_manager_thread.start()
        self.reader_thread = ReaderThread(self.lockfile, self.conn_manager_thread, self.log_file_path)
        self.reader_thread.start()

    def parse_args(self):
        parser = argparse.ArgumentParser(description='SerialKiller does serial things.')
        parser.add_argument('-p', '--port',        help="default: autodetect", default=None)
        parser.add_argument('-b', '--baudrate',    help="default: 115200", metavar='RATE', default=115200)
        parser.add_argument('-U', '--url',         help="url eg: socket://host:port", default=None)
        parser.add_argument('-t', '--timeout',     help="default: 0", default=0)
        parser.add_argument('-L', '--log',         help="log data to file", action='store_true')
        parser.add_argument('-P', '--log_dir',     help="specify log dir", default=os.path.expanduser('~'))
        parser.add_argument('-l', '--lock',        help="free serial port", action='store_true')
        parser.add_argument('-u', '--unlock',      help="reconnect to serial", action='store_true')

        parser.add_argument('-c', '--confirm_str', help="wait for this string before sending next message, when listening to STDIN", metavar='STR', default=None)
        parser.add_argument('-T', '--confirm_timeout', help="seconds before timeout when waiting for response, when listening to STDIN", metavar='TIMEOUT', default=5)
        parser.add_argument('-w', '--confirm_wait', help="wait time before sending next message, when listening to STDIN", metavar='TIME', default=1)

        parser.add_argument('-d', '--debug',       help="enable debugging", action='store_true')
        args = parser.parse_args()

        self.port = args.port
        self.baudrate = args.baudrate
        self.timeout = args.timeout
        self.debug = args.debug
        self.url = args.url
        self.do_lock = args.lock
        self.do_unlock = args.unlock
        self.do_log = args.log
        self.log_dir = args.log_dir

        self.confirm_str = args.confirm_str
        self.confirm_timeout = int(args.confirm_timeout)
        self.confirm_wait = int(args.confirm_wait)

        if args.debug:
            logger.setLevel(logging.DEBUG)
            streamhandler.setFormatter(formatter_debug)
        else:
            logger.setLevel(logging.INFO)
            streamhandler.setFormatter(formatter_info)

        # only do port discovery if no url is given
        if not self.url:
            # discover available ports if no port is supplied on CLI
            self.ports = [self.port] if self.port else [dev.device for dev in comports(include_links=True)]

            # sort USB ports to the front
            self.ports = [p for p in self.ports if 'USB' in p] + [p for p in self.ports if not 'USB' in p]

            for port in self.ports:
                logger.debug(f"Found serial port: {port}")

        self.log_dir = os.path.abspath(self.log_dir)
        if self.do_log:

            if not os.path.isdir(self.log_dir):
                logger.error('Log directory doesn\'t exist, disabling logging')
                self.log_file_path = None
            else:
                self.log_file_path = os.path.join(self.log_dir, datetime.datetime.now().strftime('%Y-%m-%d_%H_%M_%S') + '.log')
                logger.info(f"Logging to file: {self.log_file_path}")
        else:
            self.log_file_path = None

    def run(self):
        self.parse_args()

        # check if user wants to free up serial port
        if self.do_lock:
            self.lock()
            return
            
        if self.do_unlock:
            self.unlock()
            return

        self.start_threads()

        # make connection, exit on fail
        if self.url:
            if not self.conn_manager_thread.connect_TCP(self.url, self.timeout):
                self.stop_threads()
                return
        else:
            if not self.conn_manager_thread.try_connect_ports(self.ports, self.baudrate, self.timeout):
                self.stop_threads()
                return

        # create object to get input from user or stdin
        if not os.isatty(sys.stdin.fileno()):
            ic = InputSTDIN(self.conn_manager_thread,
                            self.reader_thread,
                            self.history_path,
                            self.confirm_str,
                            self.confirm_timeout,
                            self.confirm_wait)
        else:
            ic = InputUser(self.conn_manager_thread,
                           self.reader_thread,
                            self.history_path)

        # enter input loop
        try:
            ic.get_input()
        except KeyboardInterrupt:
            logger.debug("Received keyboard interrupt")
            pass
        except serial.serialutil.SerialException as e:
            logger.error(e)
            pass

        self.stop_threads()


if __name__ == "__main__":
    sk = SerialKiller()
    sk.run()
