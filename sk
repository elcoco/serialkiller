#!/usr/bin/env python3

import threading
import serial
import os,sys
import time
import argparse
import readline     # interactive mode history at input()

import logging


formatter_info = logging.Formatter('%(message)s')
formatter_debug = logging.Formatter('%(levelname)5s %(module)3s.%(funcName)-10s %(lineno)3s %(message)s')

logger = logging.getLogger('serialkiller')
logger.setLevel(logging.DEBUG)

streamhandler = logging.StreamHandler(sys.stdout)
streamhandler.setLevel(logging.DEBUG)
logger.addHandler(streamhandler)

class Helper():
    def colorize(self, string, color):
        colors = {}
        colors['black']    = '\033[0;30m'
        colors['bblack']   = '\033[1;30m'
        colors['red']      = '\033[0;31m'
        colors['bred']     = '\033[1;31m'
        colors['green']    = '\033[0;32m'
        colors['bgreen']   = '\033[1;32m'
        colors['yellow']   = '\033[0;33m'
        colors['byellow']  = '\033[1;33m'
        colors['blue']     = '\033[0;34m'
        colors['bblue']    = '\033[1;34m'
        colors['magenta']  = '\033[0;35m'
        colors['bmagenta'] = '\033[1;35m'
        colors['cyan']     = '\033[0;36m'
        colors['bcyan']    = '\033[1;36m'
        colors['white']    = '\033[0;37m'
        colors['bwhite']   = '\033[1;37m'
        colors['reset']    = '\033[0m'
        colors['default']    = '\033[0m'

        return colors[color] + string + colors["reset"]


class LockFile():
    def __init__(self, path):
        self.lockfile = path

    def is_locked(self):
        return os.path.isfile(self.lockfile)

    def lock(self):
        with open(self.lockfile, 'w'):
            pass
        logger.info(f"Created lockfile: {self.lockfile}")

    def unlock(self):
        try:
            os.remove(self.lockfile)
            logger.info(f"Removed lockfile: {self.lockfile}")
        except FileNotFoundError:
            logger.error('Serialkiller is not locked')


class ConnManager(threading.Thread, LockFile):
    def __init__(self, lockfile, port, baudrate, timeout):
        threading.Thread.__init__(self)
        LockFile.__init__(self, lockfile)
        self.stopped = False
        self.port = port
        self.baudrate = baudrate
        self.timeout = timeout
        self.ser = None

    def connect(self):
        logger.info(f"Connecting to {self.port} @ {self.baudrate}")
        try:
            self.ser = serial.Serial(self.port, self.baudrate, timeout=self.timeout)
            return self.ser
        except serial.serialutil.SerialException as e:
            logger.error(e)
            return

    def stop(self):
        logger.debug("Stopping connection manager thread")
        self.stopped = True

    def get_char(self):
        if self.ser == None:
            return
        if not self.ser.is_open:
            return
        if self.is_locked():
            return

        return self.ser.read().decode()

    def send(self, data):
        if self.ser == None:
            return
        if self.is_locked():
            logger.error("Serial is locked")
            return

        self.ser.write(data.encode())

    def close(self):
        logger.info("Closing connection")
        if self.ser != None:
            self.ser.close()

    def run(self):
        logger.debug("Starting connection manager thread")
        msg_shown = False

        while not self.stopped:
            # if serial is locked
            if self.is_locked():
                if not msg_shown:
                    logger.info("Serial is locked")
                    msg_shown = True
                    self.ser.close()

            # if serial was locked
            elif msg_shown:
                msg_shown = False
                logger.info("Serial is unlocked")
                if not self.ser.is_open:
                    self.connect()


        self.close()


class ReaderThread(threading.Thread, LockFile, Helper):
    def __init__(self, lockfile, conn_manager):
        threading.Thread.__init__(self)
        LockFile.__init__(self, lockfile)
        self.stopped = False
        self.conn_manager = conn_manager
        self.paused = False

    def stop(self):
        logger.debug("Stopping reader thread")
        self.stopped = True

    def pause(self, state):
        self.paused = state

    def sanitize(self, data):
        return data.strip(' ')

    def non_blocking_read(self):
        buf = ''
        while not self.stopped:

            if self.paused:
                continue

            c = self.conn_manager.get_char()

            if not c:
                continue
            elif c == '\n':
                return buf
            else:
                buf += c

    def run(self):
        logger.debug("Starting reader thread")
        while not self.stopped:

            try:
                data = self.non_blocking_read()
            except serial.serialutil.SerialException as e:
                continue

            if data == None:
                continue
            data = self.sanitize(data)
            if data:
                print(self.colorize('<', 'bgreen'), data)


class SerialKiller(LockFile, Helper):
    def __init__(self):
        self.lockfile = '/tmp/serialkiller.lock'
        LockFile.__init__(self, self.lockfile)

        # readline lib will use this file to read/write history
        self.history_path = '/tmp/sk_history.txt'
        try:
            readline.read_history_file(self.history_path)
        except FileNotFoundError:
            pass

    def stop_threads(self):
        self.reader_thread.stop()
        self.conn_manager_thread.stop()

    def start_threads(self):
        self.conn_manager_thread = ConnManager(self.lockfile, self.port, self.baudrate, self.timeout)
        self.conn_manager_thread.start()
        self.reader_thread = ReaderThread(self.lockfile, self.conn_manager_thread)
        self.reader_thread.start()

    def read_input(self):
        data =  input()
        readline.write_history_file(self.history_path)
        return data

    def send_data(self, data):
        print(self.colorize('>', 'bmagenta'), data)
        data += '\n'
        self.reader_thread.pause(True)
        self.conn_manager_thread.send(data)
        self.reader_thread.pause(False)

    def parse_args(self):
        parser = argparse.ArgumentParser(description='SerialKiller does serial things.')
        parser.add_argument('-p', '--port',        help="default: /dev/ttyUSB0", default='/dev/ttyUSB0')
        parser.add_argument('-b', '--baudrate',    help="default: 115200", metavar='RATE', default='115200')
        parser.add_argument('-t', '--timeout',     help="default: 0", default=0)
        parser.add_argument('-l', '--lock',        help="free serial port", action='store_true')
        parser.add_argument('-u', '--unlock',      help="reconnect to serial", action='store_true')
        parser.add_argument('-d', '--debug',       help="enable debugging", action='store_true')
        args = parser.parse_args()

        self.port = args.port
        self.baudrate = args.baudrate
        self.timeout = args.timeout
        self.debug = args.debug
        self.do_lock = args.lock
        self.do_unlock = args.unlock

        if args.debug:
            logger.setLevel(logging.DEBUG)
            streamhandler.setFormatter(formatter_debug)
        else:
            logger.setLevel(logging.INFO)
            streamhandler.setFormatter(formatter_info)

    def run(self):
        self.parse_args()

        if self.do_lock:
            self.lock()
            return
            
        if self.do_unlock:
            self.unlock()
            return

        self.start_threads()

        if not self.conn_manager_thread.connect():
            self.stop_threads()
            return

        data = ''
        while data != None:
            try:
                data = self.read_input()
                if data:
                    self.send_data(data)
            except KeyboardInterrupt:
                break

            except serial.serialutil.SerialException as e:
                logger.error(e)
                break

        self.stop_threads()

if __name__ == "__main__":
    sk = SerialKiller()
    sk.run()



