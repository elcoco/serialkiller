#!/usr/bin/env python3

import threading
import os,sys
import time
import argparse
import readline     # interactive mode history at input()
import datetime
import logging
import queue
from pathlib import Path

import serial
from serial.tools.list_ports import comports

formatter_info = logging.Formatter('%(message)s')
formatter_debug = logging.Formatter('%(levelname)5s %(module)3s.%(funcName)-10s %(lineno)3s %(message)s')

logger = logging.getLogger('serialkiller')
logger.setLevel(logging.DEBUG)

streamhandler = logging.StreamHandler(sys.stdout)
streamhandler.setLevel(logging.DEBUG)
logger.addHandler(streamhandler)

LOCK_PATH = '/tmp/serialkiller.lock'
HISTORY_PATH = '/tmp/sk_history.txt'


class Color():
    def colorize(self, string, color):
        colors = {}
        colors['black']    = '\033[0;30m'
        colors['bblack']   = '\033[1;30m'
        colors['red']      = '\033[0;31m'
        colors['bred']     = '\033[1;31m'
        colors['green']    = '\033[0;32m'
        colors['bgreen']   = '\033[1;32m'
        colors['yellow']   = '\033[0;33m'
        colors['byellow']  = '\033[1;33m'
        colors['blue']     = '\033[0;34m'
        colors['bblue']    = '\033[1;34m'
        colors['magenta']  = '\033[0;35m'
        colors['bmagenta'] = '\033[1;35m'
        colors['cyan']     = '\033[0;36m'
        colors['bcyan']    = '\033[1;36m'
        colors['white']    = '\033[0;37m'
        colors['bwhite']   = '\033[1;37m'
        colors['reset']    = '\033[0m'
        colors['default']    = '\033[0m'

        return colors[color] + string + colors["reset"]


class LockFile():
    """ Implements a lock by watching a file. If file exists, disconnect all traffic over serial port to free it up
        for another process to use. Reconnect when file is deleted.
    """
    def __init__(self, path: Path):
        self.lockfile = path

    def is_locked(self):
        return self.lockfile.is_file()

    def lock(self):
        self.lockfile.touch()
        logger.info(f"Created lockfile: {self.lockfile}")

    def unlock(self):
        if self.lockfile.is_file():
            self.lockfile.unlink()
            logger.info(f"Removed lockfile: {self.lockfile}")
        else:
            logger.error('Serialkiller is not locked')

class ConnThreadBaseClass(threading.Thread, LockFile):
    """ Handles all things that have something to do with the serial connection.
        Since serial connection can either send or receive, not both at the same time,
          a set_lock_recv() signal must be send, that frees up serial connection for sending.
        Another lock is implemented that locks both sending and receiving. (--lock|--unlock) It can be triggered
          by an external command and frees up the serial port for another process to use.
          This can be beneficial when, for example, the user wants to upload new code to an MCU
          while keeping an eye on the serial monitor.
    """
    def __init__(self, lockfile, timeout):
        threading.Thread.__init__(self)
        LockFile.__init__(self, Path(lockfile))
        self.stopped = False

        self.timeout = timeout

        # holds serial connection object
        self.ser = None

        # indicates whether we are allowed to receive, to free up port for sending
        self.lock_recv = False

        # it is impossible to detect broken connections so this indicates a reconnection try
        self.needs_reconnect = False

        # put received chars in queue
        self.chr_q = queue.Queue()

    def is_alive(self):
        return self.ser != None

    def set_lock_recv(self, state):
        # set lock to free up port for sending (see docstring)
        self.lock_recv = state

    def stop(self):
        logger.debug("Stopping connection manager thread")
        self.stopped = True

    def recv_chr(self):
        # receive a single character
        if self.ser == None:
            return
        if not self.ser.is_open:
            return
        if self.is_locked():
            return

        # check if we are allowed to receive, this is done to free up port for sending
        if self.lock_recv:
            return

        try:
            c = self.ser.read().decode()
            if c:
                self.chr_q.put(c)
                return c

        except UnicodeDecodeError as e:
            logger.error(e)
            logger.error(f"Wrong baudrate? {self.baudrate}")
        except serial.serialutil.SerialException as e:
            self.needs_reconnect = True

    def send(self, data):
        # send a line
        if self.ser == None:
            return
        if self.is_locked():
            logger.error("Serial is locked")
            return

        self.set_lock_recv(True)
        self.ser.write(data.encode())
        self.set_lock_recv(False)

    def close(self):
        if self.ser != None:
            self.ser.close()

    def run(self):
        logger.debug("Starting connection manager thread")
        msg_shown = False

        while not self.stopped:
            if self.is_locked():
                if not msg_shown:
                    logger.info("Serial is locked")
                    self.close()
                    msg_shown = True

            else:
                if self.needs_reconnect or self.ser == None or not self.ser.is_open:
                    self.connect()
                    msg_shown = False

            self.recv_chr()
            time.sleep(0.01)
        self.close()


class SerialConnThread(ConnThreadBaseClass):
    def __init__(self, lockfile, ports, baudrate, timeout):
        ConnThreadBaseClass.__init__(self, lockfile, timeout)

        self.ports = ports
        self.baudrate = baudrate

        # this will be the port after successfull first connection
        self.port = None


    def connect_serial(self, port, show_error=True):
        # Create connection over Serial port
        try:
            self.ser = serial.Serial(port, self.baudrate, timeout=self.timeout, exclusive=True)
            logger.info(f"Connected to {port} @ {self.baudrate} | Exit using CTRL+C")

            # save serial connection info so we can reconnect quicker
            self.port = port
            self.needs_reconnect = False
            return self.ser
        except serial.serialutil.SerialException as e:
            if show_error:
                logger.error(e)

    def reconnect(self):
        """ Connection has been established before.
            Keep trying to reconnect """
        self.close()
        logger.info("Attempting to reconnect...")
        while not self.ser.is_open:
            if self.connect_serial(self.port, show_error=False):
                break
            time.sleep(0.1)


    def connect(self):
        # try all ports in list, NOTE discovery is somehow super slow from thread
        if self.port != None:
            self.reconnect()
            return True

        for port in self.ports:
            logger.info(f"Trying to connect to {port}")
            if self.connect_serial(port):
                return True
        else:
            logger.error("No serial ports found")
            self.stopped = True



class TCPConnThread(ConnThreadBaseClass):
    def __init__(self, lockfile):
        ConnThreadBaseClass.__init__(self, lockfile)

        self.url = None

    def connect(self, url, timeout=1):
        # Create connection over TCP
        try:
            self.ser =  serial.serial_for_url(url, timeout=timeout)
            logger.info(f"Connected to {url} | Exit using CTRL+C")
            self.url = url
            return self.ser
        except serial.serialutil.SerialException as e:
            logger.error(e)


class ReaderThread(threading.Thread, LockFile, Color):
    """ Reads data from the connection an prints it to STDOUT and optionally to a file """
    def __init__(self, lockfile, conn_manager, log_file_path):
        threading.Thread.__init__(self)
        LockFile.__init__(self, Path(lockfile))
        self.stopped = False
        self.conn_manager = conn_manager
        self.log_file_path = log_file_path

    def stop(self):
        logger.debug("Stopping reader thread")
        self.stopped = True

    def sanitize(self, data):
        return data.strip()

    def write_to_log_file(self, data):
        with open(self.log_file_path, 'a') as f:
            f.write(data + '\n')

    def run(self):
        logger.debug("Starting reader thread")
        buf = ""

        while not self.stopped:

            while not self.conn_manager.chr_q.empty():

                c = self.conn_manager.chr_q.get()

                if c == None:
                    continue

                if c == '\n':
                    if buf and self.log_file_path:
                        self.write_to_log_file(buf)
                    buf = ""

                elif c:
                    if not buf:
                        print(self.colorize('< ', 'bgreen'), end='')

                    buf += c

                else:
                    logger.error(f"Received weird things: >{c}<")
                    continue

                print(c, end='')


            time.sleep(0.1)


class InputBaseClass(Color):
    """ Handles the way data is retrieved from either user, STDIN or whatever before it is sent over the serial connection """
    def __init__(self, conn_manager_thread, reader_thread, history_path):
        self.reader_thread = reader_thread
        self.conn_manager_thread = conn_manager_thread
        self.history_path = history_path

    def send_data(self, data):
        self.conn_manager_thread.send(data + '\n')
        print(self.colorize('>', 'bmagenta'), data)


class InputUser(InputBaseClass):
    """ Handles user input """
    def __init__(self, conn_manager_thread, reader_thread, history_path):
        super().__init__(conn_manager_thread, reader_thread, history_path)

    def get_input(self):
        logger.debug("Starting reading from user input")
        while True:
            data = input()
            readline.write_history_file(self.history_path)

            if data:
                self.send_data(data)


class InputSTDIN(InputBaseClass):
    """ Handles input over STDIN (pipe) """
    def __init__(self, conn_manager_thread, reader_thread, history_path, confirm_str, confirm_timeout, confirm_wait):
        super().__init__(conn_manager_thread, reader_thread, history_path)
        self.confirm_str = confirm_str
        self.confirm_timeout = confirm_timeout
        self.confirm_wait = confirm_wait

    def wait_for_str(self, confirm_str, timeout=5):
        msg = ''
        t = datetime.datetime.now()

        # wait till we get the expected response, timeout if not
        while msg != confirm_str:
            if (datetime.datetime.now() - t) > datetime.timedelta(seconds=timeout):
                logger.error("Message timed out")
                return
            if not self.reader_thread.q.empty():
                msg = self.reader_thread.q.get()
        return msg

    def get_input(self):
        if self.confirm_str:
            logger.info(f"Starting reading from STDIN, string={self.confirm_str}, timeout={self.confirm_timeout} sec")
        else:
            logger.info(f"Starting reading from STDIN, wait={self.confirm_wait} sec")

        for c,l in enumerate(sys.stdin):
            l = l.rstrip('\n')

            if not l:
                continue

            print(self.colorize(f"< [{c}]", "bblue"), l)
            self.send_data(l)

            # wait for response, either by response string or wait time
            if self.confirm_str:
                self.wait_for_str(self.confirm_str, self.confirm_timeout)
            else:
                time.sleep(self.confirm_wait)

        logger.debug("STDIN buffer empty")


class SerialKiller(LockFile):
    """ Main application class, starts/stops connection and reader threads and enters an input loop """
    def __init__(self):
        self.lockfile = LOCK_PATH
        LockFile.__init__(self, Path(self.lockfile))

        # readline lib will use this file to read/write history
        self.history_path = HISTORY_PATH
        try:
            readline.read_history_file(self.history_path)
        except FileNotFoundError:
            pass

    def start_threads(self):
        # make connection, exit on fail
        if self.url:
            self.conn_manager_thread = TCPConnThread(self.lockfile)
            self.conn_manager_thread.start()
        else:
            self.conn_manager_thread = SerialConnThread(self.lockfile, self.ports, self.baudrate, self.timeout)
            self.conn_manager_thread.start()

        self.reader_thread = ReaderThread(self.lockfile, self.conn_manager_thread, self.log_file_path)
        self.reader_thread.start()

    def stop_threads(self):
        self.reader_thread.stop()
        self.conn_manager_thread.stop()

    def parse_args(self):
        parser = argparse.ArgumentParser(description='SerialKiller does serial things.')
        parser.add_argument('-p', '--port',        help="default: autodetect", default=None)
        parser.add_argument('-b', '--baudrate',    help="default: 115200", metavar='RATE', default=115200)
        parser.add_argument('-U', '--url',         help="url eg: socket://host:port", default=None)
        parser.add_argument('-t', '--timeout',     help="default: 1", metavar='SEC', default=1)
        parser.add_argument('-L', '--log',         help="log data to file", action='store_true')
        parser.add_argument('-P', '--log_dir',     help="specify log dir", metavar='DIR', default=os.path.expanduser('~'))
        parser.add_argument('-l', '--lock',        help="free serial port", action='store_true')
        parser.add_argument('-u', '--unlock',      help="reconnect to serial", action='store_true')

        parser.add_argument('-S', '--confirm_str', help="wait for this string before sending next message, when listening to STDIN", metavar='STR', default=None)
        parser.add_argument('-T', '--confirm_timeout', help="seconds before timeout when waiting for response, when listening to STDIN", metavar='SEC', default=5)
        parser.add_argument('-W', '--confirm_wait', help="wait time before sending next message, when listening to STDIN", metavar='SEC', default=1)

        parser.add_argument('-d', '--debug',       help="enable debugging", action='store_true')
        args = parser.parse_args()

        self.port = args.port
        self.baudrate = args.baudrate
        self.timeout = args.timeout
        self.debug = args.debug
        self.url = args.url
        self.do_lock = args.lock
        self.do_unlock = args.unlock
        self.do_log = args.log
        self.log_dir = args.log_dir

        self.confirm_str = args.confirm_str
        self.confirm_timeout = int(args.confirm_timeout)
        self.confirm_wait = int(args.confirm_wait)

        if args.debug:
            logger.setLevel(logging.DEBUG)
            streamhandler.setFormatter(formatter_debug)
        else:
            logger.setLevel(logging.INFO)
            streamhandler.setFormatter(formatter_info)

        # only do port discovery if no url is given
        if not self.url:
            # discover available ports if no port is supplied on CLI
            self.ports = [self.port] if self.port else [dev.device for dev in comports(include_links=True)]

            # sort USB ports to the front
            self.ports = [p for p in self.ports if 'USB' in p] + [p for p in self.ports if not 'USB' in p]

            for port in self.ports:
                logger.debug(f"Found serial port: {port}")

        self.log_dir = os.path.abspath(self.log_dir)
        if self.do_log:

            if not os.path.isdir(self.log_dir):
                logger.error('Log directory doesn\'t exist, disabling logging')
                self.log_file_path = None
            else:
                self.log_file_path = os.path.join(self.log_dir, datetime.datetime.now().strftime('%Y-%m-%d_%H_%M_%S') + '.log')
                logger.info(f"Logging to file: {self.log_file_path}")
        else:
            self.log_file_path = None

    def wait_for_connection(self, thread):
        while not thread.stopped:
            if thread.is_alive():
                return True

    def run(self):
        self.parse_args()

        # check if user wants to free up serial port
        if self.do_lock:
            self.lock()
            return
            
        if self.do_unlock:
            self.unlock()
            return

        self.start_threads()

        # wait for initial connection. exit on fail
        if not self.wait_for_connection(self.conn_manager_thread):
            self.stop_threads()
            return

        # create object to get input from user or stdin
        if not os.isatty(sys.stdin.fileno()):
            ic = InputSTDIN(self.conn_manager_thread,
                            self.reader_thread,
                            self.history_path,
                            self.confirm_str,
                            self.confirm_timeout,
                            self.confirm_wait)
        else:
            ic = InputUser(self.conn_manager_thread,
                           self.reader_thread,
                            self.history_path)

        # enter input loop
        try:
            ic.get_input()
        except KeyboardInterrupt:
            logger.debug("Received keyboard interrupt")
        except serial.serialutil.SerialException as e:
            logger.error(e)

        self.stop_threads()


if __name__ == "__main__":
    sk = SerialKiller()
    sk.run()
